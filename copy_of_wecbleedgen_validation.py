# -*- coding: utf-8 -*-
"""Copy of WECBleedGen Validation

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14C_teG5_9tLQpQayc0tGqzP-FBRDvkMw

**WCEBleedGen Validation**
"""

from tensorflow.keras.metrics import Precision, Recall, BinaryAccuracy
import tensorflow as tf
import os
import numpy as np
from matplotlib import pyplot as plt

"""Loading data"""

from google.colab import drive
drive.mount('/content/drive')

from tensorflow.keras.models import load_model

model_path = '/content/imageclassifier (1).h5'

model = load_model(model_path)

!unzip drive/My\ Drive/WCEBleedGen.zip

data = tf.keras.utils.image_dataset_from_directory('WCEBleedGen')

# we cannot fetch data directly so we are using numpy iterator
data_iterator = data.as_numpy_iterator()

batch = data_iterator.next()

class_labels = ["GI Bleeding", "No GI Bleeding"]
'''
0 => GI Bleeding
1 => No GI Bleeding '''

#SPLIT DATA

train_size = int(len(data)*.7)
val_size = int(len(data) * .1)
test_size = int(len(data)*.2)+1

train = data.take(train_size)
val = data.skip(train_size).take(val_size)
test = data.skip(train_size + val_size).take(test_size)

"""Evaluate Performance"""

pre = Precision()
re = Recall()
acc = BinaryAccuracy()

for batch in test.as_numpy_iterator():
    X, y = batch
    yhat = model.predict(X)
    pre.update_state(y, yhat)
    re.update_state(y, yhat)
    acc.update_state(y, yhat)

print(f'Precision:{pre.result().numpy()}, Recall:{re.result().numpy()}, Accuracy:{acc.result().numpy()}')

f1_score = (2*pre.result().numpy()*re.result().numpy())/(pre.result().numpy()+re.result().numpy())
f1_score

from sklearn.metrics import confusion_matrix
import seaborn as sns

plt.figure(figsize = (16,9))
y_pred_labels = [np.argmax(label) for label in yhat]   # we find the single level value from single image of the 10th neuron prediction value(y_pred)
cm = confusion_matrix(y, y_pred_labels)

# show cm
sns.heatmap(cm, annot = True, fmt = 'd', xticklabels = class_labels, yticklabels = class_labels)
# annot-value should be above box, fmt - decimel, xticklabels- label on x axis and vice versa

from sklearn.metrics import classification_report

# Extract true labels from the test dataset
test_labels = np.concatenate([y for x, y in test], axis=0)

# Predict using the model
y_pred = model.predict(test)

# Convert probabilities to binary classes using a threshold (0.5 in this case)
y_pred_classes = (y_pred > 0.5).astype(int)

# Generate and print the classification report
print(classification_report(test_labels, y_pred_classes))

"""Save the model"""

from tensorflow.keras.models import load_model

model.save(os.path.join('models','imagevalidator.h5'))